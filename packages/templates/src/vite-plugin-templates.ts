import fs from "fs";
import path from "path";
import type { Plugin } from "vite";

interface TemplateInfo {
	name: string;
	component: string;
	importName: string;
	key: string;
	filePath: string;
}

function toCamelCase(str: string): string {
	return str.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
}

function toPascalCase(str: string): string {
	return str
		.replace(/\s+/g, "")
		.replace(/^[a-z]/, (match) => match.toUpperCase());
}

function extractTemplateInfo(filePath: string): TemplateInfo | null {
	try {
		const content = fs.readFileSync(filePath, "utf-8");
		const fileName = path.basename(filePath, ".tsx");

		// Extract component name from default export
		const defaultExportMatch = content.match(
			/export\s+default\s+function\s+(\w+)/,
		);
		if (!defaultExportMatch) {
			console.warn(`No default export found in ${filePath}`);
			return null;
		}

		const componentName = defaultExportMatch[1];

		// Extract name export
		const nameExportMatch = content.match(
			/export\s+const\s+name\s*=\s*["'`]([^"'`]+)["'`]/,
		);
		if (!nameExportMatch) {
			console.warn(`No name export found in ${filePath}, using filename`);
			const fallbackName = fileName
				.replace(/-/g, " ")
				.split(" ")
				.map((word) => word.charAt(0).toUpperCase() + word.slice(1))
				.join(" ");

			const importName = `${toPascalCase(fallbackName)}Template`;

			return {
				name: fallbackName,
				component: componentName,
				importName,
				key: toCamelCase(fileName.replace(/-template$/, "")),
				filePath,
			};
		}

		const templateName = nameExportMatch[1];
		const key = toCamelCase(fileName.replace(/-template$/, ""));
		const importName = `${toPascalCase(templateName)}Template`;

		return {
			name: templateName,
			component: componentName,
			importName,
			key,
			filePath,
		};
	} catch (error) {
		console.error(`Error reading template file ${filePath}:`, error);
		return null;
	}
}

function generateTemplatesFile(templatesDir: string, outputPath: string): void {
	try {
		const files = fs.readdirSync(templatesDir).sort();

		const templates: TemplateInfo[] = [];

		for (const file of files) {
			const filePath = path.join(templatesDir, file);
			const templateInfo = extractTemplateInfo(filePath);
			if (templateInfo) {
				templates.push(templateInfo);
			}
		}

		if (templates.length === 0) {
			console.warn("No valid templates found");
			return;
		}

		// Generate imports using the importName
		const imports = templates
			.map((template) => {
				const relativePath = `../templates/${path.basename(template.filePath, ".tsx")}`;
				return `import ${template.importName} from "${relativePath}";`;
			})
			.join("\n");

		// Generate templates object using importName
		const templatesObject = templates
			.map((template) => {
				return `\t${template.key}: { name: "${template.name}", component: ${template.importName} },`;
			})
			.join("\n");

		// Generate the complete file content
		const content = `// ⚠️ AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// This file is automatically generated by the templates plugin.
// To add a new template, run 'pnpm create-template "Template Name"'
// and export a 'name' const. The plugin will automatically regenerate this file.

${imports}

const templates = {
${templatesObject}
} as const;

export type TemplateType = keyof typeof templates;
export default templates;
`;

		// Write the file
		fs.writeFileSync(outputPath, content);
		console.log(
			`✅ Generated templates.gen.ts with ${templates.length} templates`,
		);
	} catch (error) {
		console.error("Error generating templates file:", error);
	}
}

function isTemplateFile(filePath: string): boolean {
	return filePath.includes("/templates/") && filePath.endsWith(".tsx");
}

function handleTemplateChange(
	filePath: string,
	action: "changed" | "added" | "removed",
	templatesDir: string,
	outputPath: string,
	server?: any,
): void {
	if (!isTemplateFile(filePath)) return;

	const fileName = path.basename(filePath);
	const actionEmojis = {
		changed: "🔄",
		added: "➕",
		removed: "🗑️",
	};

	console.log(`${actionEmojis[action]} Template ${action}: ${fileName}`);
	generateTemplatesFile(templatesDir, outputPath);

	// Trigger HMR for the templates file if server is available
	if (server) {
		const module = server.moduleGraph.getModuleById(outputPath);
		if (module) {
			server.reloadModule(module);
		}
	}
}

export function templatesPlugin(): Plugin {
	let templatesDir: string;
	let outputPath: string;

	return {
		name: "templates-generator",
		configResolved(config) {
			const srcDir = path.resolve(config.root, "src");
			templatesDir = path.join(srcDir, "templates");
			outputPath = path.join(srcDir, "utils", "templates.gen.ts");
		},

		buildStart() {
			// Generate templates file on build start
			if (fs.existsSync(templatesDir)) {
				generateTemplatesFile(templatesDir, outputPath);
			}
		},

		configureServer(server) {
			const watcher = server.watcher;
			watcher.add(templatesDir);

			watcher.on("change", (filePath) =>
				handleTemplateChange(
					filePath,
					"changed",
					templatesDir,
					outputPath,
					server,
				),
			);

			watcher.on("add", (filePath) =>
				handleTemplateChange(
					filePath,
					"added",
					templatesDir,
					outputPath,
					server,
				),
			);

			watcher.on("unlink", (filePath) =>
				handleTemplateChange(
					filePath,
					"removed",
					templatesDir,
					outputPath,
					server,
				),
			);
		},
	};
}
